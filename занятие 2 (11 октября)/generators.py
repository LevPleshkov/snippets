# функция-генератор объявляется как обычная функция, но вместо `return` 
# для возврата значения используется `yield`
def random_0_1(seed):
    # начальное состояние - сдвиг на 127 битов влево и 1 в первый бит:
    # при seed = 1, state = 0b100000....00001
    state = seed << 127 | 1

    # бесконечный цикл не будет выполняться бесконечно, 
    while True:
        new_bit = ((state >> 7) ^ (state >> 2) ^ (state >> 1) ^ state) & 1
        state = (state >> 1) | (new_bit << 127)
        yield new_bit


# счетчик сгенерированных нулей
zeros = 0

# используем генератор для генерации псевдослучайных 0 и 1.
# генератор возвращает 'ленивый' итератор - последовательность
# значений, которая не хранится в памяти целиком, а используется 
# по мере необходимости.
for digit in random_0_1(1):
    # вывод каждого текущего 0 или 1. именованый аргумент `end` со значением `''`
    # позволяет не выводить каждый раз символ новой строки `\n`, а печатать все 
    # символы друг за другом.
    print(digit, end='')

    # увеличиваем счет 0, и если их накопилось больше 10_000 - прерываем цикл.
    zeros = zeros if digit == 1 else zeros + 1  # условный оператор `if-else` в одной строке 
                                                # (аналог оператора `? :` в других языках)

    # оператор `break` здесь прерывает и цикл, и работу генератора
    if zeros > 100000:
        break
