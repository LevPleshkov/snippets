# функция-генератор объявляется как обычная функция, но вместо `return` 
# для возврата значения используется `yield`
def random_0_1(seed):
    # начальное состояние - сдвиг на 127 битов влево и 1 в первый бит:
    # при seed = 1, state = 0b100000....00001
    state = seed << 127 | 1

    # бесконечный цикл не будет выполняться бесконечно, а только тогда,
    # когда этого потребует вызвавший генератор объект.
    while True:
        # узнаем новый бит, который будет записан последним после сдвига.  для этого 
        # сдвигаем состояние на 7, 2, 1 и 0 битов вправо, применяя XOR.  AND с 0b..0001
        # позволяет получить лишь значение последнего бита.
        new_bit = ((state >> 7) ^ (state >> 2) ^ (state >> 1) ^ state) & 1
        # обновляем состояние.  сдвигаем новый бит в конец, а состояние на 1 бит вправо.
        # OR позволит сохранить все 1 из обоих битовых последовательностей `state` и `new_bit`.
        state = (state >> 1) | (new_bit << 127)
        # возвращаем новый бит.  `yield` не обязан быть посленей строкой.
        yield new_bit


# счетчик сгенерированных нулей
zeros = 0

# используем генератор для генерации псевдослучайных 0 и 1.
# генератор возвращает 'ленивый' итератор - последовательность
# значений, которая не хранится в памяти целиком, а используется 
# по мере необходимости.
for digit in random_0_1(1):
    # вывод каждого текущего 0 или 1. именованый аргумент `end` со значением `''`
    # позволяет не выводить каждый раз символ новой строки `\n`, а печатать все 
    # символы друг за другом.
    print(digit, end='')

    # увеличиваем счет 0, и если их накопилось больше 10_000 - прерываем цикл.
    zeros = zeros if digit == 1 else zeros + 1  # условный оператор `if-else` в одной строке 
                                                # (аналог оператора `? :` в других языках)

    # оператор `break` здесь прерывает и цикл, и работу генератора
    if zeros > 100000:
        break
